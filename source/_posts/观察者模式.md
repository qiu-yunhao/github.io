# 观察者模式

起因是某个项目中遇到的一个问题: 目前有三个不同的数据库进行加载，量不一样，无法预计哪个先搞完，但三个数据库加载完成后加载的闪屏结束。emmmm，真的恶心，小小年纪背负了不该有的痛苦。学长说这是一个较为复杂的观察者模式，头大！！！但终归还是要学习相关的东西，问题毕竟是要人解决的嘛。。。（原谅我现在才处理）

## 什么是观察者模式

*定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。*

![DzlWK.png](https://s1.328888.xyz/2022/07/27/DzlWK.png)

## 一对一公平solo

简而言之，就是一个观察者，一个被观察者。

![](http://tva3.sinaimg.cn/large/ceeb653ely8gy0zxdxfv6g208c08ct91.gif)

你留在女（男）神的聊天页面，等待着她（他）回消息。神么，你没女（男）神的QQ/微信？！那你当不了观察者了，关掉吧（bushi）



### 初始版

欢迎来到对抗路（上单孤儿）

```java
class Myself{
    public void sendMessage(){
        System.out.println("回复消息");
    }
}

class Goddess{
    private int state;
    private Myself myself;

    Goddess(int state){
        this.state = state;
    }

    public void setState(int state){
        if(state != this.state) {
            this.state = state;
            myself.sendMessage();
        }
    }

    public void setObserver(Myself myself){
        this.myself = myself;
    }
}

public class QQ {
    public static void main(String[] args){
        Goddess goddess = new Goddess(1);
        Myself myself = new Myself();
        goddess.setObserver(myself);
        goddess.setState(2);
    }
}

```



### 抽象版

你的女神不知道你到底是什么类，但为了联系，把你弄到一个叫观察者的分组

```java
interface Observer{
    void sendMessage();
}

class Myself implements Observer{
    public void sendMessage(){
        System.out.println("回复消息");
    }
}

class Goddess{
    private int state;
    private Observer observer;

    Goddess(int state){
        this.state = state;
    }

    public void setState(int state){
        if(state != this.state) {
            this.state = state;
            observer.sendMessage();
        }
    }

    public void setObserver(Observer observer){
        this.observer = observer;
    }
}

public class QQ {
    public static void main(String[] args){
        Goddess goddess = new Goddess(1);
        Myself myself = new Myself();
        goddess.setObserver(myself);
        goddess.setState(2);
    }
}

```

### 相关思考

是不是发现逻辑逻辑有点问题？是你来观察女（男）神，不应该由她来绑定你，应该由你来绑定她/他。emmmm咋一听没啥问题，甚至很有道理。那假如观察者有个观察者的List，里面全是被观察者。观察者怎么查看被观察者状态改变呢？



## 一对多正义群殴

也就是一个被观察者可以绑定多个观察者，这种更贴近现实一点。就好像关注的up的动态更新一样。当你关注的up主更新时，会更新你的消息队列一样。当多个up更新，你的消息也会成队列更新。

```java

import java.util.ArrayList;
import java.util.List;

interface Observer{
    void update(int id);
}

abstract class Observable {
    protected int id;
    protected List<Observer> observers;
    public void addObserver(Observer observer){
        observers.add(observer);
    }
    public void removeObserver(Observer observer) {
        int index = observers.indexOf(observer);
        if (index > -1) {
            observers.remove(observer);
        }
    }
    public void notifyAllObservers(){
        for (Observer o : observers){
            o.update(id);
        }
    }
}

class User implements Observer{
    private int id;

    User(int id){
        this.id = id;
    }
    @Override
    public void update(int id) {
        System.out.println("用户:" + this.id + "收到up" + id + "的最新动态");
    }
}

class Up extends Observable{
    Up(int id){
        this.id = id;
        this.observers = new ArrayList<>();
    }

    public void showNewVideo(){
        System.out.println("更新动态");
        notifyAllObservers();
    }
}

class Bilibili{
    public static void main(String[] args){
        Up up = new Up(1);
        for(int i = 0 ; i < 10 ; i++){
            User u = new User(i + 1);
            up.addObserver(u);
        }

        up.showNewVideo();
    }
}
```



## 异步相关

什么？QwQ这玩意还有异步？！不学了不学了（doge）

![](https://pic1.zhimg.com/80/v2-554320105b5b0d75e081a539d3415490_720w.jpg)

异步非阻塞观察者模式，顾名思义，就是让观察者执行异步，主线程的执行不受它们的执行的影响。

### 概念辨析

我们先来辨析一下同步和异步的区别，同样用刷b站来展示一下

* 同步：up主更新视频，你正在刷的视频中断，然后跳到up猪的新视频
* 异步：up主更新视频，你正在刷的视频继续，然后头部弹出消息通知(消息不弹更准确一点)

同步仍需要对应的主线程做出响应，异步状态下就是主线程点点头，表示已阅并不影响当前的工作，就像上述例子，up发完视频之后干自己的事，就属于异步，所有硬币点赞都是观众老爷的事，同步状态下，她说不定闲了，当是观众们怕不是G了。

### plan 1

让通知由另一条线程处理，就完成了最简单的异步

```java
class User implements Observer{
    private int id;

    User(int id){
        this.id = id;
    }
    @Override
    public void update(int id) {
        Thread thread = new Thread(){
            @Override
            public void run() {
                super.run();
                System.out.println("用户收到up" + id + "的最新动态");
            }
        };
        thread.start();
    }
}
```

缺点：

* 线程的不断创建开销大，可能炸栈
* 每条线程不可控

### plan 2

使用线程池（Executor）来避免不断的线程的创建和销毁

```java
interface Observer{
    void update(int id);
}

abstract class Observable {
    protected int id;
    protected List<Observer> observers;
    public void addObserver(Observer observer){
        observers.add(observer);
    }
    public void removeObserver(Observer observer) {
        int index = observers.indexOf(observer);
        if (index > -1) {
            observers.remove(observer);
        }
    }
    public void notifyAllObservers(){
        for (Observer o : observers){
            o.update(id);
        }
    }
}

class User implements Observer{
    private int id;

    User(int id){
        this.id = id;
    }
    @Override
    public void update(int id) {
        System.out.println("用户收到up" + id + "的最新动态");
    }
}

class Up extends Observable{
    private Executor executor;
    Up(int id,Executor executor){
        this.id = id;
        this.observers = new ArrayList<>();
        this.executor = executor;
    }

    public void showNewVideo(){
        System.out.println("更新动态");
        for(Observer o : observers ){
            executor.execute(() -> o.update(id));
        }
    }

    public void setExecutor(Executor executor) {
        this.executor = executor;
    }
}

class Bilibili{
    public static void main(String[] args){
        Up up = new Up(1, Executors.newCachedThreadPool());
        for(int i = 0 ; i < 10 ; i++){
            User u = new User(i + 1);
            up.addObserver(u);
        }
        up.showNewVideo();
    }

```

缺点：

* 代码的耦合性太高，维护起来麻烦

### plan 3

 使用EventBus来实现，需要额外导入包



## 多对一拓展延申

依据概念貌似没有一个观察者面对多个被观察者，当被观察者都发生变化时，观察者才做出响应。就好像一些安全上的相关东西一样。他会有一定的类似于误差的东西，只有当多个被观察者全部变化时才说明问题的严重性，需要及时处理



[![Dz0oJ.png](https://s1.328888.xyz/2022/07/27/Dz0oJ.png)](https://imgloc.com/image/Dz0oJ)



```java
public class MainActivity extends AppCompatActivity {
    Handler handler;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        TextView textView = findViewById(R.id.textView);
        textView.setOnClickListener(v->{
            v.setBackgroundColor(Color.RED);
        });
        handler = new Handler(){
            @Override
            public void handleMessage(@NonNull Message msg) {
                super.handleMessage(msg);
                System.out.println("完成更新");
            }
        };

        Up up1 = new Up(1),up2 = new Up(2), up3 = new Up(3);
        User user = new User(0x100);
        user.addSubjects(up1);
        user.addSubjects(up2);
        user.addSubjects(up3);
        up1.addObserver(user);
        up2.addObserver(user);
        up3.addObserver(user);
        Thread thread1 = new TestThread(up1);
        Thread thread2 = new TestThread(up2);
        Thread thread3 = new TestThread(up3);
        thread1.start();
        thread2.start();
        thread3.start();

    }

    class TestThread extends Thread {
        private Up up;
        TestThread(Up up){
            this.up = up;
        }

        @Override
        public void run(){
            int t = new Random().nextInt(10);
            try {
                sleep(t * 1000);
                System.out.println(up + "在"+ t + "秒时发布动态");
                up.showNewVideo();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    class User implements Observer{
        private int id;
        private List<Observable> subjects;
        private Vector<Boolean> simples;
        User(int id){
            this.id = id;
            subjects = new ArrayList<>();
            simples = new Vector<>();
        }
        @Override
        public void update(Observable observable) {
            Thread thread = new Thread(){
                @Override
                public void run() {
                    super.run();
                    int index = subjects.indexOf(observable);
                    simples.set(index,true);
                    if (Judge()){
                        handler.sendEmptyMessage(0x10001);
                    }
                }
            };

            thread.start();
        }

        private synchronized boolean Judge(){
            boolean ans = true;
            for(boolean b : simples){
                if(!b){
                    ans = false;
                }
            }
            return ans;
        }

        public void addSubjects(Observable observable){
            subjects.add(observable);
            simples.add(false);
        }
    }
}



interface Observer{
    void update(Observable observable);
}

abstract class Observable {
    protected int id;
    protected List<Observer> observers;
    public void addObserver(Observer observer){
        observers.add(observer);
    }
    public void removeObserver(Observer observer) {
        int index = observers.indexOf(observer);
        if (index > -1) {
            observers.remove(observer);
        }
    }
    public void notifyAllObservers(){
        for (Observer o : observers){
            o.update(this);
        }
    }

    @Override
    public String toString() {
        return "被观察者" + id ;
    }
}



class Up extends Observable{
    Up(int id){
        this.id = id;
        this.observers = new ArrayList<>();
    }

    public void showNewVideo(){
        System.out.println("更新动态");
        notifyAllObservers();
    }

}

```

代码架构有点乱（懒）