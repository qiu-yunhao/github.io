---
title: 杂乱无章
date: 2021-10-30
tags: c android
---



# 杂乱无章

之前对每个人都进行了采访，你们都打太极给我圆过去，所以我也不知道该给你们讲点啥，你们咋就这么难伺候呢？索性我就随便讲讲了。

<!-- more -->

## 1.结构体与类

### 结构体Struct

#### 结构体的定义

在[C语言](https://baike.baidu.com/item/C语言)中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为[变量](https://baike.baidu.com/item/变量/5271)、[指针](https://baike.baidu.com/item/指针)或[数组](https://baike.baidu.com/item/数组)等，用以实现较复杂的[数据结构](https://baike.baidu.com/item/数据结构/1450)。结构体同时也是一些元素的[集合](https://baike.baidu.com/item/集合/2908132)，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。

```c
struct Number
{
    int a;
    int b;
} 
```

声明的时候直接struct Number num = {a,b};

#### 结构体的作用 

结构体和其他类型基础[数据类型](https://baike.baidu.com/item/数据类型)一样，例如int类型、char类型，只不过结构体可以做成你想要的数据类型。以方便日后的使用。

#### 结构体的意义

结构体描述了一段内存的解释意义。在内存中，数据的意义在于如何使用此段数据，如在内存中存有一个数据3，如果只把他当作正整数来使用，那么其意义为正整数3，如果把内存中的3，当作2的3次方来使用，那么3的意义则为指数3。而一个结构体则描述了一段内存中的数据的使用意义。

用上面的Number来表示就是num{2,3};

### 类Class

#### 什么是类？

类的内部[封装](https://baike.baidu.com/item/封装/2796965)了[属性](https://baike.baidu.com/item/属性/20192958)和[方法](https://baike.baidu.com/item/方法/2444)，用于操作自身的成员。类是对某种[对象](https://baike.baidu.com/item/对象/2331271)的定义，具有[行为](https://baike.baidu.com/item/行为/4541853)（[behavior](https://baike.baidu.com/item/behavior/2326387)），它描述一个对象能够做什么以及做的[方法](https://baike.baidu.com/item/方法/2444)（method），它们是可以对这个对象进行操作的程序和过程。它包含有关对象行为方式的信息，包括它的[名称](https://baike.baidu.com/item/名称/6546057)、[属性](https://baike.baidu.com/item/属性/20192958)、[方法](https://baike.baidu.com/item/方法/2444)和[事件](https://baike.baidu.com/item/事件/6129089)。

类的实质是**一种引用数据类型**，类似于 [byte](https://baike.baidu.com/item/byte/810420)、[short](https://baike.baidu.com/item/short/4729482)、[int](https://baike.baidu.com/item/int/54055)（char）、[long](https://baike.baidu.com/item/long/412402)、[float](https://baike.baidu.com/item/float/19167524)、[double](https://baike.baidu.com/item/double/2726635) 等基本数据类型，不同的是它是一种复杂的数据类型。因为它的本质是[数据类型](https://baike.baidu.com/item/数据类型/10997964)，而不是[数据](https://baike.baidu.com/item/数据/5947370)，所以不存在于内存中，不能被直接操作，只有被实例化为对象时，才会变得可操作。

```c++
class Customer{
    private:
        int money;
    public:
        Customer();
        Customer(int money);
        void pay_for_bill(Barber &barber);
         ~Customer();
         void read();
};
```

这里我们可以看到，在成员变量以及函数面前还有public和private等关键字进行修饰，使其拥有不同的特性。

### 类与结构体的区别

* 从职能观点来看，class 表现为行为；而 struct 常用于存储数据。
* class 支持继承，可以继承自类和[接口](https://baike.baidu.com/item/接口/2886384)；而 struct 没有[继承性](https://baike.baidu.com/item/继承性/9589682)，struct 不能从 class 继承，也不能作为 class 的[基类](https://baike.baidu.com/item/基类)，但 struct 支持[接口继承](https://baike.baidu.com/item/接口继承/2475168)。
* class 可以声明**无参**[构造函数](https://baike.baidu.com/item/构造函数/7478717)，可以声明**有参**[构造函数](https://baike.baidu.com/item/构造函数/7478717)；而 struct 只能声明带参数[构造函数](https://baike.baidu.com/item/构造函数/7478717)，且不能声明无参[构造函数](https://baike.baidu.com/item/构造函数/7478717)。因此，struct 没有自定义的默认无参构造函数，默认无参[构造函数](https://baike.baidu.com/item/构造函数)只是简单地把所有值[初始化](https://baike.baidu.com/item/初始化/100108)为它们的 0 等价值。
* [Java](https://baike.baidu.com/item/Java/85979) 中，实例化时，class 要使用 new [关键字](https://baike.baidu.com/item/关键字)；而 struct 可以不使用 new 关键字，如果不以 new 来实例化 struct，则其所有的字段将处于未分配状态，直到所有字段完成初始化，否则引用未赋值的字段会导致编译错误。
* class 可实现[抽象类](https://baike.baidu.com/item/抽象类)（[abstract](https://baike.baidu.com/item/abstract/2216763)），可以声明[抽象方法](https://baike.baidu.com/item/抽象方法/2953555)（抽象函数）；而 struct 为抽象，也不能声明[抽象函数](https://baike.baidu.com/item/抽象函数/8101234)。
* class 的对象复制分为[浅拷贝](https://baike.baidu.com/item/浅拷贝/8648181)和[深拷贝](https://baike.baidu.com/item/深拷贝/22785317)，必须经过特别的方法来完成复制；而 struct 创建的对象复制简单，可以直接以等号连接即可。
* class 实例由垃圾回收机制来保证内存的回收处理；而 struct 变量使用完后立即自动解除[内存分配](https://baike.baidu.com/item/内存分配)。
* 作为[参数传递](https://baike.baidu.com/item/参数传递)时，class 变量是以按址方式传递；而 struct 变量是以按值方式传递的。

#### 简单的理解

上面哔哔赖赖了一大堆，我估计你们应该也没听懂啥，这一部分只是给你们留个印象，等后续学Java的过程中对类的概念有更深入的理解后，再头回来看看这个会有更深的体会。

好了，那我们来简单理解一下类和结构体的区别，结构体在某种程度上是一种信息表单，它会储存这个类别中所有成员的特称，就像老师每次发的信息表一样，每一行就可以看作一个Struct student，其中的成员变量有你的名字，性别，身高，等等。而类更倾向于描述学生这一类个体，除了上面提到的身高，性别，年龄等，还会描述你的行为，比如你会走，你能打太极折磨学长等等。那你会说我还可以定义方法让这个结构体去执行，这样也是在描述这个结构体的信为。没错，但这样与类区别就是，一个是你要他做什么，和他会做什么之间的区别。



## 字符串与string

在c语言中没有String的概念，所有的字符串都用字符数组来储存。字符串的声明，输入，输出应该都会，这里就不再介绍了。

### 字符串的储存

* 在C语言中，字符串以’\0’作为结尾标志
* 在字符数组中，scanf（）后会自动在最后一个字符后面添加’\0’，所以在声明字符数组时应至少比输入的字符串的长度多1

 #### 而在处理未知字符串长度的时候，不方便定义的时候我们有以下两种处理方式：

##### 基础版

这个就很好弄了，咱们直接定义一个大一点的就好：char a[10000];比如就这样

##### 进阶版

使用动态内存分配

C语言版：

```c
#include <stdio.h>
#include <stdlib.h>

#define Next_Add 10

int main(){
    int strLen = 10;
    char *s = (char *) malloc(sizeof(char)*strLen);
    int number = 0;
    char ch;
    printf("请输入一段字符串：\n");
    do{
        ch = getchar();
        s[number] = ch;
        number++;
        if(number>=strLen){
            strLen += Next_Add;
            s = realloc(s,sizeof(char)*(strLen+1));
        }
    }while(ch != '\n');
    s[number] = '\0';
    printf("%s",s);
    return 0;
}
```

输出结果：

[![5v6ek4.png](https://z3.ax1x.com/2021/10/30/5v6ek4.png)](https://imgtu.com/i/5v6ek4)

#### 字符串储存溢出

```c
#include <stdio.h>
#include <string.h>
int main(){
    char a[4];
    memset(a,0,4);
    scanf("%s",a);
    int t = strlen(a);
    printf("%s\n",a);
    return 0;
}
```

可以看到我们定义的数组大小只有4，而我们输入的是“123456”，长度为6

结果：

[![5v6V7F.png](https://z3.ax1x.com/2021/10/30/5v6V7F.png)](https://imgtu.com/i/5v6V7F)

有些编译器会给出字符越界的警告(有些还不会！)，不过可能，在程序员眼中，wanring ！= error因而就是没问题的(doge)

##### 这个有什么危害呢？

往小了说，顶多就是一些变量的数据相互覆盖，程序结果运行出来的结果就离谱，往大了说，一些黑客能直接淦穿程序，拿到控制权。所以还是要规范定义。



### string类

这边放一个简单的string类的实现，这个比头文件导入的low多了，但可以简单反应一下string类的基本特征：

```c++
class String{
	private:
		char *str;
		int len;
	public:
		void showStr(){
			cout<< this->str <<endl;
		}
		
		String(){
			this->str = NULL;
	        this->len = 0;
		}
		
		String(const char *str){
			this->str = new char[strlen(str) + 1];
	        strcpy(this->str,str);
	        this->len = strlen(str);
		}
		
		String(String &s){
			this->str = new char[s.len + 1];
	        strcpy(this->str,s.str);
        	this->len = s.len;
		}
		
		String operator + (char *s){
			String string;
	        string.len = strlen(s) + this->len;
	        string.str = new char[strlen(s) + this->len + 1];
	        strcpy(string.str,this->str);
	        strcpy(string.str + this->len,s);
        	return string;
		}
		
		String operator = (char *s){
			this->len = strlen(s);
	        if(this->str != NULL){
		        delete[] this->str;
	        }
	        this->str = new char[strlen(s) + 1];
	        strcpy(this->str,s);
        	return *this;
		}
		
		String operator + (const String &s){
			String string;
	        string.len = s.len + this->len;
	        string.str = new char[s.len + this->len + 1];
	        strcpy(string.str,this->str);
	        strcpy(string.str + this->len,s.str);
	        return string;
		}
		String operator = (const String &s){
			this->len = s.len;
			if (this->str != NULL)
		        delete[]str;
	        this->str = new char[this->len + 1];
	        strcpy(this->str, s.str);
	        return *this;
		}
		~String(){
			cout<<"析构"<<endl;
		}
}; 
```

我们可以看到这个string类里面有一个char类的指针和一个表示长度的interesting型变量len。而char数组本身就是利用指针来读取数据的，可简单看作一个char类的指针。所以string类可以看作char数组的延申，使之成为一个整体。



## android的自定义绘图

接下来介绍Android自定义的绘图！（长叹一声！真累人）

### 工具简介

工欲善其事，必先利其器，我们来介绍主要的工具Canvas（），Path（），Point（）/PointF（），Paint（）;下面就介绍一点简单的绘制方法和流程

#### Canvas类：

  canvas（画布）是用来在屏幕上绘画的类，可以根据一定的设置画出自定义的任何视图。

![这里写图片描述](https://img-blog.csdn.net/2018072121442999)

###### translate方法

这个方法就是更换坐标原点的位置：比如canvas.translate(100,100);

![这里写图片描述](https://img-blog.csdn.net/20180722134109440)

我们可以看到，这里是将坐标原点位移至（100，100）的位置，然后再以该点作为原点，经行后续过程。

其他的就简单说一下比如

* drawRect()和drawRoundRect()绘制矩阵，传入参数：上下左右的坐标，和paint
* drawCircle()传入参数：圆心的坐标的x，y，半径r，和paint
* drawArc()传入参数：所化曲线的范围RectF，开始绘制的角度，绘制角的大小，是否经过圆心，paint

#### Path类

Path封装了由直线和曲线(二次，三次贝塞尔曲线)（这个还没怎么看过）构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，也可以用于剪裁画布和根据路径绘制文字。它具体的作用就是来辅助Canvas进行绘图。

* moveTo(x，y)将会图的点移动至(x,y)Float型，将（x,y）作为起始点，不画线.
* LineTo(x,y)将点从起始位置画线至（x，y），并把（x，y）作为新的起始点

#### Point类/PointF类

这两个类都是用来储存点的位置信息的，那么他们究竟有什么区别？

**Point类的构造函数：**

```Java
public Point(int x, int y) {
     this.x = x;
     this.y = y;
 }

```

**PointF类的构造函数:**

```Java
public PointF(float x, float y) {
    this.x = x;
    this.y = y; 
 }
```

这里可以看到他们的区别主要是构造函数传入的参数的不同，Point类用来处理整形的坐标,PointF类用来处理浮点型的坐标

#### Paint类

在自定义组件中，Paint类是一个很重要的类，主要包含颜色、文本、图形样式、位图模式、滤镜等几个方面。

* setSytle(): 选择填充模式，stroke,fill,fill and stroke三个模式，对应只绘制边缘线，只绘制边缘线内的部分（不含边缘线）,前面两种的总和。这个真的很重要！一定要设置，不然容易让你的自定义View不成型，即一块白板，咋样都看不出来
* setAntiAlias() : 是否开启抗锯齿模式
* setStrokeWidth() : 边缘线的宽度
* setColor() ：选择填充颜色
* setAlpha()：设置透明度

剩余的功能还有很多，后面有机会我再讲讲，今晚实在肝不动了QaQ

### 开始干活

1.思考构图要素，比如我怎么用数学来计算个个点的坐标，再利用path去完成图像的绘制，比如我们要绘制一个这样的雷达六边形我们可以利用三角函数来处理。

```java
private PointF[] somePoint = {
            new PointF(0, 1),
            new PointF((float) Math.sin(Angle_60), (float) Math.cos(Angle_60)),
            new PointF((float) Math.sin(Angle_60 * 2), (float) Math.cos(Angle_60 * 2)),
            new PointF((float) Math.sin(Angle_60 * 3), (float) Math.cos(Angle_60 * 3)),
            new PointF((float) Math.sin(Angle_60 * 4), (float) Math.cos(Angle_60 * 4)),
            new PointF((float) Math.sin(Angle_60 * 5), (float) Math.cos(Angle_60 * 5))
    };
```



2.利用点来描述该路径的最外面一层

```java
private void initEdge(float r) {
        PointF mPoint;
        mList = new ArrayList<>(EndNumber);
        for (int i = 0; i < EndNumber; i++) {
            mPoint = new PointF();
            mPoint.x = somePoint[i].x * r;
            mPoint.y = somePoint[i].y * r;
            mList.add(mPoint);
        }
    }
```

```Java
private void initLine(Canvas canvas) {
        Path path = new Path();
        for (int i = 0; i < 5; i++) {
            float size = r - (r / 5) * i;
            initEdge(size);
            PointF p = mList.get(0);
            path.moveTo(p.x, p.y);
            canvas.drawText(String.valueOf(20*(5-i)),-p.x,-p.y,mTextPaint);
            for (int j = 1; j < EndNumber; j++) {
                p = mList.get(j);
                path.lineTo(p.x, p.y);
                int a = Integer.MAX_VALUE;
            }
            path.close();
            if(i%2==0){
                mAreaPaint.setColor(color);
                mAreaPaint.setAlpha(10);
                canvas.drawPath(path,mAreaPaint);
            }else{
                mAreaPaint.setColor(Color.WHITE);
                canvas.drawPath(path,mAreaPaint);
            }
            canvas.drawPath(path, mLinePaint);
            path.reset();
        }
        
        //canvas.drawPath(path, mLinePaint);
        //path.reset();

         /**
         * 画六条射线
         */
        for (int i = 0; i < EndNumber; i++) {
            initEdge(r);
            path.moveTo(0, 0);
            PointF pointF = mList.get(i);
            path.lineTo(pointF.x, pointF.y);
        }
        canvas.drawPath(path, mLinePaint);

    }
```



3.我们绘制图片实际上是对onDraw函数的重写

```java
protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        initPaint();
        canvas.translate(width / 2, height / 2);//将初始位置移至区域中心
        initLine(canvas);//绘制背景部分
        initText(canvas);//绘制文字部分
        initPoint(canvas);//绘制圈起来的区域部分


    }
```







[![5v6mtJ.png](https://z3.ax1x.com/2021/10/30/5v6mtJ.png)](https://imgtu.com/i/5v6mtJ)



### 结束语

真的很抱歉啊，这次想讲的东西有点多，但准备的额不是很齐全，这篇分享，尤其是后面这部分写的很差劲，进本就是在cv，实在是太困了，这一周基本没咋睡过好觉......顶不住了，没有周六的时间，只能匆匆了事，等今天结束，我再好好的完善一下吧。

#### 六边形雷达图的全部代码

```Java
public class Hexagon extends View {
    private final double Angle_60 = Math.PI / 3;
    private float centerX = getX();
    private float centerY = getY();
    private float r = 300f;
    private float testSize = 36;
    private Context mContext;
    private int EndNumber = 6;
    private int width, height;
    private int color = Color.BLUE;

    private Paint mLinePaint, mAreaPaint, mTextPaint;

    private List<PointF> mList;
    private final String[] text = {"Hello,android1", "Hello,android2", "Hello,android3", "Hello,android4", "Hello,android5", "Hello,android6"};

    private int[] score = {6, 7, 6, 4, 10, 5};
    private PointF[] somePoint = {
            new PointF(0, 1),
            new PointF((float) Math.sin(Angle_60), (float) Math.cos(Angle_60)),
            new PointF((float) Math.sin(Angle_60 * 2), (float) Math.cos(Angle_60 * 2)),
            new PointF((float) Math.sin(Angle_60 * 3), (float) Math.cos(Angle_60 * 3)),
            new PointF((float) Math.sin(Angle_60 * 4), (float) Math.cos(Angle_60 * 4)),
            new PointF((float) Math.sin(Angle_60 * 5), (float) Math.cos(Angle_60 * 5))
    };

    public Hexagon(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        this.mContext = context;
    }

    public Hexagon(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        this.mContext = context;
    }

    public Hexagon(Context context) {
        super(context);
        this.mContext = context;
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        this.width = w;
        this.height = h;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        initPaint();
        canvas.translate(width / 2, height / 2);
        initLine(canvas);
        initText(canvas);
        initPoint(canvas);


    }

    private void initLine(Canvas canvas) {
        Path path = new Path();
        /**
         * 画六条射线
         */

        for (int i = 0; i < 5; i++) {
            float size = r - (r / 5) * i;
            initEdge(size);
            PointF p = mList.get(0);
            path.moveTo(p.x, p.y);
            canvas.drawText(String.valueOf(20*(5-i)),-p.x,-p.y,mTextPaint);
            for (int j = 1; j < EndNumber; j++) {
                p = mList.get(j);
                path.lineTo(p.x, p.y);
                int a = Integer.MAX_VALUE;
            }
            path.close();
            if(i%2==0){
                mAreaPaint.setColor(color);
                mAreaPaint.setAlpha(10);
                canvas.drawPath(path,mAreaPaint);
            }else{
                mAreaPaint.setColor(Color.WHITE);
                canvas.drawPath(path,mAreaPaint);
            }
            canvas.drawPath(path, mLinePaint);
            path.reset();
        }
        
        //canvas.drawPath(path, mLinePaint);
        //path.reset();

        for (int i = 0; i < EndNumber; i++) {
            initEdge(r);
            path.moveTo(0, 0);
            PointF pointF = mList.get(i);
            path.lineTo(pointF.x, pointF.y);
        }
        canvas.drawPath(path, mLinePaint);

    }

    private void initPaint() {
        mLinePaint = new Paint();
        mLinePaint.setStrokeWidth(3);
        mLinePaint.setColor(color);
        mLinePaint.setAntiAlias(true);
        mLinePaint.setStyle(Paint.Style.STROKE);

        mAreaPaint = new Paint();
        mAreaPaint.setStyle(Paint.Style.FILL);
        mAreaPaint.setColor(Color.BLUE);
        mAreaPaint.setAntiAlias(true);
        mAreaPaint.setAlpha(10);

        mTextPaint = new Paint();
        mTextPaint.setAntiAlias(true);
        mTextPaint.setColor(color);
        mTextPaint.setStyle(Paint.Style.FILL);
        mTextPaint.setStrokeWidth(3);
        mTextPaint.setTextAlign(Paint.Align.LEFT);
        mTextPaint.setTextSkewX((float) -0.25);
        mTextPaint.setTextSize(36);
    }

    private void initEdge(float r) {
        PointF mPoint;
        mList = new ArrayList<>(EndNumber);
        for (int i = 0; i < EndNumber; i++) {
            mPoint = new PointF();
            mPoint.x = somePoint[i].x * r;
            mPoint.y = somePoint[i].y * r;
            mList.add(mPoint);
        }
    }

    private void initText(Canvas canvas) {
        initEdge(r);
        mTextPaint.setTextAlign(Paint.Align.CENTER);
        PointF p = mList.get(0);
        float wid = mTextPaint.measureText(text[0]);
        canvas.drawText(text[0], p.x, p.y + (float) (testSize * 1.2), mTextPaint);

        p = mList.get(1);
        wid = mTextPaint.measureText(text[1]);
        canvas.drawText(text[1], p.x + wid / 2 + (float) (testSize * 0.6), p.y + (float) (testSize * 0.5), mTextPaint);

        p = mList.get(2);
        wid = mTextPaint.measureText(text[2]);
        canvas.drawText(text[2], p.x + wid / 2 + (float) (testSize * 0.6), p.y + (float) (testSize * 0.4), mTextPaint);

        p = mList.get(3);
        wid = mTextPaint.measureText(text[3]);
        canvas.drawText(text[3], p.x, p.y - (float) (testSize * 0.8), mTextPaint);

        p = mList.get(4);
        wid = mTextPaint.measureText(text[4]);
        canvas.drawText(text[4], p.x - (float) (testSize * 0.6) - wid / 2, p.y + (float) (testSize * 0.4), mTextPaint);

        p = mList.get(5);
        wid = mTextPaint.measureText(text[5]);
        canvas.drawText(text[5], p.x - (float) (testSize * 0.6) - wid / 2, p.y + (float) (testSize * 0.5), mTextPaint);

    }

    public void initPoint(Canvas canvas){
        initEdge(r);
        mAreaPaint.setColor(Color.BLUE);
        mAreaPaint.setAlpha(50);
        PointF p = mList.get(0);
        Path path = new Path();
        path.moveTo(p.x*(float) (score[0]/10.0),p.y*(float) (score[0]/10.0));
        for(int i = 1;i<EndNumber;i++){
            p = mList.get(i);
            path.lineTo(p.x*(float) (score[i]/10.0),p.y*(float) (score[i]/10.0));
        }
        path.close();
        canvas.drawPath(path,mAreaPaint);
    }

    public void setColor(int color){
        this.color = color;
        invalidate();
    }

    public void setR(float r) {
        this.r = r;
        invalidate();
    }

    public void setTestSize(float textSize){
        this.testSize = textSize;
        invalidate();
    }

    public void setScore(int[] score){
        this.score = score;
        invalidate();
    }
}
```

