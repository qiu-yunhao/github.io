# 动态规划--初见

我语文不怎么好，而且最近写的有点题颠覆了我的认知，所以我把动态规划的定义放在最后，那么先用一个例子来引入我印象中的动态规划。
<!-- more -->
## 例1

[![IzGHQ1.png](https://z3.ax1x.com/2021/11/22/IzGHQ1.png)](https://imgtu.com/i/IzGHQ1)

很明显，这里作为懒人的我们会使用递推(主要是不会递归，对吧)

```java
class Solution {
    public int fib(int n) {
        if(n<2){
            return n;
        }else{
            int[] nums = new int[n+1];
            nums[0] = 0;
            nums[1] = 1;
            for(int i = 2; i < n+1 ;i++){
                nums[i] = nums[i-1] + nums[i-2];
            }
            return nums[n];
        }
    }
}

```

之后再来看看递归：

```Java
class Solution {
    public int fib(int n) {
        if(n == 1 || n==2)
            return 1;
    
        return fib(n-1) + fib(n-2);
        
    }
}
```

通过leetcode，我们发现递归的速度比递推要慢很多。

原因：

所以这里就是我们传统思想中的动态规划，它规避了对递归中数据的反复调用查询，而选着直接将其储存，这样就在后面要访问这个数据时提高了运算速度。

## 例2

那么接着看一个生活相关的问题：

[![IzansA.png](https://z3.ax1x.com/2021/11/22/IzansA.png)](https://imgtu.com/i/IzansA)

那么我们看到这个题目第一时间是怎么想的？应该是比如 11 应该是

```java
11 - 5 = 6;
6-5 = 1;
1
```

 这样感觉很不错，那么代码实现一下：

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        int sum = 0;
        for(int i = coins.length-1; i >= 0; i--){
            sum += amount / coins[i];
            amount = amount % coins[i];
        }
        if(amount!=0){
            return -1;
        }else{
             return sum;
        }       
    }
}
```

然后提交！大功告成！提交！QaQ

[![IzdYtK.png](https://z3.ax1x.com/2021/11/22/IzdYtK.png)](https://imgtu.com/i/IzdYtK)

我只能说！不愧是你，leetcode！

那么现在来分析一下这个问题出在哪里？

举个例子：

如果我们选择的钱币是【1，5，11】没错，这个国家就是这样奇葩,而我们需要兑换的钱币为15

那我们的代码的选择如下：

```Java
15 - 11 = 4;
4 - 1 = 3;
3 - 1 = 2;
2 - 1 = 1;
1
```

而实际上是

```
15 - 5 = 10;
10 - 5 = 5;
5;
```

我们的代码的这种策略称为“**贪心**”：假设我们面对的局面是“需要凑出w”，**贪心策略会尽快让w变得更小**。能让w少11就尽量让它少11，这样我们接下来面对的局面就是凑出w-11。而本题中凑完11之后我们要面临凑4的局面，此时凑4的代价是很大的，这里就体现了贪心的局限性，它没有大局观，有点鼠目寸光。

接下来是动态规划的代码：

```Java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        int max = amount + 1;
        Arrays.fill(dp,max);
        dp[0] = 0;
        for(int i = 1;i <= amount; i++){
            for(int j = 0; j < coins.length; j++){
                if(i>=coins[j])
                    dp[i] = Math.min(dp[i - coins[j]] + 1,dp[i]);
            }
        } 
        return dp[amount] >= max ? -1 : dp[amount];
    }
}
```

动态规划中我们使用递推，通过状态转移的方法来对问题进行求解

我们先解决一下的问题

* 怎么设置dp对应的属性
* 相应的dp[i]怎么得到 和 如何建立相关的状态转移方程

这里首先看题目是求相应金额所转换的最小金币数所以就直接用dp[i] 表示i转换相应的金币需要的最小金币。

然后就来思考这个dp[i]怎么得到

[![oS37PH.jpg](https://z3.ax1x.com/2021/11/22/oS37PH.jpg)](https://imgtu.com/i/oS37PH)



至此解答完毕。

## dp的适用性

由此我们来看一下动态规划的一些性质：

* 后无效性

  严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。

  比如要凑出dp[15]，我们的关注点在于如何求出dp[4],dp[10]和dp[14],而我们是利用递推来解题的，也就是说，我们在求出dp[15]之前已经求出了dp[4],dp[10]和dp[14]。而在求出dp[15]时，这个结果对之前的所有的值都没有影响，即“**未来对过去无效**”。

* 最优子结构

  回顾我们对dp[i]的定义：我们记“凑出i所需的**最少**钞票数量”为dp[i].

  dp[i]的定义就已经蕴含了“最优”。利用amount=14,10,4的**最优**解，我们即可算出w=15的**最优**解。

  大问题的**最优解**可以由小问题的**最优解**推出，这个性质叫做“最优子结构性质”。

那么什么时候可以使1用dp？

就是**能将大问题拆成几个小问题，且满足无后效性、最优子结构性质**

## 例3

[![ ](https://z3.ax1x.com/2021/11/22/oSEm3F.png)](https://imgtu.com/i/oSEm3F)

这道题就很简单了，可以现场想一下刚刚的做题方法，现场试一试，做完我们再继续讲

下面上解题代码

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] sum = new int[n];
        if(n == 1){
            return nums[0];
        }else if(n == 2){
            return Math.max(nums[0], nums[1]);
        }else{
            sum[0] = nums[0];
            sum[1] = Math.max(nums[0], nums[1]);
        for(int i = 2; i < n; i++){
            sum[i] = Math.max(sum[i-1], sum[i-2] + nums[i]);
        }
        return sum[n-1];
        }
    }
}

```



## 例4

那么我们来一道变种题

[![oSVwzF.png](https://z3.ax1x.com/2021/11/22/oSVwzF.png)](https://imgtu.com/i/oSVwzF)

哎，成环了，惊不惊喜，意不意外！

 那么就是需要化曲为直，来这道题换成上道题，进而来求解这道题。

我们来分析一下这两道题不同的地方，上面那道是直接一条直线过去，这边成了环，那么偷n-1的时候会对0有影响吗？而且0和n不能同时取到，这会不会导致一些情况漏解？

想到这里就说明确实是在动脑子了doge，那么怎么解决呢？

我们作为专业小偷是不回头的，一次性会把东西偷干净，所以无论从哪个点切入都是一样的，偷完了，也不会影响之前偷过的，所以第一个问题解决了。那么下一个，都0和n不能同时取了能漏什么，这个担心是多余的。

化曲为直部分：正因为0和n不能同时取，所以当选择偷0时，n是不会碰的，而当偷n时，0也是不会碰的，那么就把相应的状况剔除，即为处理**0~n-1**和**1~n**，通过上一题的方法进行求解，再把这两个答案进行比较，即可得到最终答案。

上代码

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 1){
            return nums[0];
        }
        int[] dp1 = new int[n];
        int[] dp2 = new int[n];
        for(int i = 0; i < n-1; i++){
            dp1[i] = Math.max(dp1[(i - 1 + n)%n],dp1[(i - 2 + n)%n]+nums[i]);
            dp2[i+1] = Math.max(dp2[i],dp2[( i - 1 + n ) % n] + nums[i + 1]);
        }
        return Math.max(dp2[n-1],dp1[n-2]);
    }
}
```



## 例5

[![oSZaTI.png](https://z3.ax1x.com/2021/11/22/oSZaTI.png)](https://imgtu.com/i/oSZaTI)

现在开始颠覆认知：这道题却不是使用dp，而是使用递归，但标签仍然是动态规划，可以用状态转移的方法来思考

```java
class Solution {
    public int integerReplacement(int n) {
        if(n == 1){
            return 0;
        }
      if(n % 2 == 0){
            return integerReplacement(n/2) + 1;
        }else{
   
            return Math.min(integerReplacement(n-1),integerReplacement(n-1)/2 + 1)+1;
        }
    }
}
```



就有点颠覆我之前的认知，为此我特地翻了一下leetcode上对动态规划的定义，如下

## 定义

```
动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。

动态规划有自底向上和自顶向下两种解决问题的方式。自顶向下即记忆化递归，自底向上就是递推。

使用动态规划解决的问题有个明显的特点，一旦一个子问题的求解得到结果，以后的计算过程就不会修改它，这样的特点叫做无后效性，求解问题的过程形成了一张有向无环图。动态规划只解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。
```

感觉还是有点抽象，但没有关系，因为我也糊了！QwQ

我打算写点系列性的东西，所以以后也会有相应的介绍，就且听下回分解？

