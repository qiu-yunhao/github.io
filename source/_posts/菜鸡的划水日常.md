----

title: 菜鸡组会分享
date: 2021-6-11
tags: android

-----

# Visibilty()和Gilde的用法

<!-- more -->

## 1.前言

​        呜呜呜，这是第二遍写了。铁汁们，一定要边写遍保存，不说了（默默按下CTRL+s）在写这个新项目时，让我发现书斋真是个宝库，好多都可以借鉴。上次写了个分享，内容殷实，语言简练，所以承蒙命运眷顾，学期末再来一次（这波叫有是有终  :-)  ），让我自我拯救......由于我能力有限，在写项目的时候疯狂报错，遭受了亿点点挫折，就选择一点近期遇到的问题，分享一下。

## 2.Visibility()

这个是因为我在处理RecyclerView的单次点击事件时，但打算像原来那样用两个Apadter来处理这个问题，但我在实现的时候在构造器里添加了一个Boolean的属性，而在网络请求时返回的没有这个Boolean，就...反正我感觉自己走进死胡同了。

### 1.属性

* VISIBLE(可见的)
* INVISIBLE(不可见的)  控件会占用其空间，但不会显示出来

* GONE(隐藏的)  控件不会占用空间，也不会显示出来

### 2.使用

用setVisibility()来设置就行，例如

```
public void hide(){
            textView_link.setVisibility(View.GONE);
            linearLayout.setVisibility(View.GONE);
            imageView1.setVisibility(View.GONE);
            textView1.setVisibility(View.GONE);
            imageView2.setVisibility(View.GONE);
            textView2.setVisibility(View.GONE);
            imageView3.setVisibility(View.GONE);
            textView3.setVisibility(View.GONE);
        }
```

下面来看下具体例子（GONE）

![image1](https://z3.ax1x.com/2021/06/05/2NksQ1.jpg)

（请大家放我一马，别冲我）

如上设置后看效果

![image2](https://z3.ax1x.com/2021/06/05/2NknZ8.jpg)



而设置成（INVISIBLE）

![image3](https://z3.ax1x.com/2021/06/05/2NkUdU.jpg)

这样应该很清楚GONE和INVISIBLE的区别了

## 3.项目更新图片

我们知道在获取返回类时，avatars里面装的是图片地址，我们的第一个翻译就是使用网络请求，单纯就此讲一下网络请求中更新图片。

首先，正常情况下不会选择Retrofit来进行对大量图片的请求，因为Retrofit使用时要填充baseUrl，并且在GET里要再次填充后面的部分，因为大量图片的baseUrl是不同的，因此拿到网址再用方法处理这个事情时会额外花费一定时间，得不偿失。当然，会有和我一样的人敢于尝试，就是直接不填GET里面的部分，全部丢到baseUrl里，很遗憾，Android Studio把我捶回地面，直接报错（baseUrl必须以'/'结尾）。

### 1.初次尝试

下面展示一下代码部分

```
 Handler handler = new Handler() {
            @SuppressLint("HandlerLeak")
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                if (msg.what == 0x8848) {
                    holder.imageView.setImageBitmap(bitmap);
                    Log.d("Main_Activity", "尝试更新图片");
                }
            }
        };
        new Thread(new Runnable() {
            @Override
            public void run() {
                URL url = null;
                try {
                    List<String> uList = uDto.getAvatars();
                    url = new URL(uList.get(0));
                    Log.d("GET_TRY", url.toString());
                } catch (MalformedURLException e) {
                    e.printStackTrace();
                }
                InputStream inputStream = null;//将输入的字节流设置为空
                try {
                    inputStream = url.openStream();//通过URL对象的openStream（）方法能够得到指定资源的输入流。
                } catch (IOException e) {
                    e.printStackTrace();
                }
                bitmap = BitmapFactory.decodeStream(inputStream);//进行解码
                handler.sendEmptyMessage(0x8848);//handler发送信息

            }
        }).start();
    }
```

* 这里补充一下InputStream
  * 我们在进行Android java 开发的时候，经常会遇到各种IO流操作。IO流操作一般分为两类：字符流和字节流。以“Reader”结尾都是字符流，操作的都是字符型的数据；以“Stream”结尾的都是字节流，操作的都是byte数据。
  * InputStream 和 OutputStream为各种输入输出字节流的基类，所有字节流都继承这两个基类。

* 再补充一下Handler有关的内容
  * ![image4](/home/qyh/Pictures/20180602153124808.jpeg)
  * 在Android，这里的线程分为有消息循环的线程和没有消息循环的线程，有消息循环的线程一般都会有一个Looper，这个事android的新  概念。我们的主线程（UI线程）就是一个消息循环的线程。针对这种消息循环的机制，我们引入一个新的机制Handle，我们有消息循环，就要往消息循环里  面发送相应的消息，自定义消息一般都会有自己对应的处理，消息的发送和清除，消息的的处理，把这些都封装在Handle里面，注意Handle只是针对那 些有Looper的线程，不管是UI线程还是子线程，只要你有Looper，我就可以往你的消息队列里面添加东西，并做相应的处理。
  * Handle在哪个线程创建就和哪个线程的Looper关联，当然在构造Handler是亦可以传入指定的Looper
  * 具体的我也不太清楚，建议直接翻学姐的hexo博客

这样更新的话特点是耗时长(今天重新测试的时候速度有明显的提升，是网络问题还是mvp模式？)，而且在加载的时候会出现图像重复加载和错位。

以下是效果（5s左右）：

**...没找到类似于视频床的东西（菜狗）**

### 2.再次尝试

为了解决那个问题，我在百度上查了好久，有一种用ASYNCTASK异步处理的升级版方法，反正我没成功(狗头)。这中方法要重写这儿，重写那儿的。emmmmm,不符合我的懒人思想，所以就没太深究。再次之后我了解到一种全新的方法Glide。我反正看到的特点就是简单。

```
Glide.with(context)
    .load(url)//设置请求的url
    .priority (Priority.HIGH)//有多个Gilde时用优先级区别，这里设置为高
    .placeholder(R.drawable.place_image)//图片加载出来前，显示的图片；类似于等待时的显示
    .error(R.drawable.error_image)//图片加载失败后，显示的图片
    .thumbnail(0.2f)//Glide 将会显示原始图片的20%的大小
    .override(width,height)//这里的单位是px,这个可以无视视图本来的大小进行显示
    .skipMemoryCache(true)//跳过内存缓存；一般默认都是false，不用写
    .diskCacheStrategy( DiskCacheStrategy.NONE )//关闭磁盘缓存
    .into(imageView);//更新哪个图片
```

当然了，Glide还能再定义什么加载动画啊什么的，反正功能挺多的。使用时只用三个最基本的.with().load().into()三个属性就能使用。

展示实操例子(我这里用的是Glide4，语法上有些不同)

```
RequestOptions options = new RequestOptions()
                .placeholder(R.mipmap.test);

        Glide.with(context)
                .asBitmap()//设置加载的类型，还有其他的类...
                .load(url)
                .apply(options)
                .into(holder_choose.imageView);
    }
```

好简洁啊，有木有QwQ

效果如下（4s左右）：

**...没找到类似于视频床的东西（菜狗）**

这个可以解决那个图片加载错位的问题。

### 3.未来尝试——下次一定

还有一种叫Fresco的方法，很实用，听学长说更新网络图片很多用这个方法。好家伙，一百度出来就说，这个方法专为Android更新图片而生！！！看起来b格就很高。